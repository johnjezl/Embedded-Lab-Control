#!/usr/bin/env python3
"""
generate-udev-rules.py - Generate udev rules for deterministic USB serial naming.

This script generates udev rules that create symlinks under /dev/lab/ for
USB serial devices based on their physical USB port path.

Usage:
    # Interactive mode - discover devices and prompt for names
    ./generate-udev-rules.py

    # From mapping file
    ./generate-udev-rules.py --mapping mapping.yaml

    # Output to file
    ./generate-udev-rules.py --output /etc/udev/rules.d/99-lab-serial.rules

Mapping file format (YAML):
    ports:
      - usb_path: "1-10.1.3"
        name: "sbc1-console"
      - usb_path: "1-10.1.4"
        name: "sbc2-console"
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path

try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


UDEV_RULE_TEMPLATE = """\
# {comment}
SUBSYSTEM=="tty", KERNELS=="{usb_path}", SYMLINK+="lab/{name}", MODE="0666"
"""

UDEV_HEADER = """\
# Lab Controller USB Serial Device Rules
# Generated by generate-udev-rules.py
#
# These rules create deterministic symlinks under /dev/lab/ based on
# physical USB port paths, ensuring consistent device naming regardless
# of enumeration order.
#
# To apply: sudo udevadm control --reload-rules && sudo udevadm trigger

"""


def discover_devices() -> list[dict]:
    """Run discover-usb-serial.sh and parse JSON output."""
    script_dir = Path(__file__).parent
    discover_script = script_dir / "discover-usb-serial.sh"

    if not discover_script.exists():
        print(f"Error: {discover_script} not found", file=sys.stderr)
        sys.exit(1)

    result = subprocess.run(
        [str(discover_script), "--json"],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Error running discovery script: {result.stderr}", file=sys.stderr)
        sys.exit(1)

    try:
        devices = json.loads(result.stdout)
    except json.JSONDecodeError as e:
        print(f"Error parsing discovery output: {e}", file=sys.stderr)
        sys.exit(1)

    return devices


def load_mapping(mapping_file: Path) -> dict[str, str]:
    """Load USB path to name mapping from YAML file."""
    if not YAML_AVAILABLE:
        print("Error: PyYAML not installed. Run: pip install pyyaml", file=sys.stderr)
        sys.exit(1)

    with open(mapping_file) as f:
        data = yaml.safe_load(f)

    mapping = {}
    for port in data.get("ports", []):
        usb_path = port.get("usb_path")
        name = port.get("name")
        if usb_path and name:
            mapping[usb_path] = name

    return mapping


def interactive_mapping(devices: list[dict]) -> dict[str, str]:
    """Interactively prompt user to name each discovered device."""
    print("\nDiscovered USB serial devices:")
    print("-" * 70)

    for i, dev in enumerate(devices, 1):
        print(f"  {i}. {dev['device']:10} USB:{dev['usb_path']:12} "
              f"{dev['vendor'][:15]:15} {dev['model'][:25]}")

    print("-" * 70)
    print("\nEnter a name for each device (or press Enter to skip):")
    print("Names should be lowercase, alphanumeric with hyphens (e.g., 'sbc1-console')\n")

    mapping = {}
    for dev in devices:
        default_name = f"port-{dev['usb_path'].replace('.', '-')}"
        prompt = f"  {dev['device']} ({dev['usb_path']}) [{default_name}]: "

        try:
            name = input(prompt).strip()
        except (EOFError, KeyboardInterrupt):
            print("\nAborted.")
            sys.exit(1)

        if not name:
            name = default_name

        # Validate name
        if not all(c.isalnum() or c == '-' for c in name):
            print(f"    Warning: '{name}' contains invalid characters, using default")
            name = default_name

        mapping[dev["usb_path"]] = name.lower()

    return mapping


def generate_rules(mapping: dict[str, str], devices: list[dict]) -> str:
    """Generate udev rules from mapping."""
    # Build device info lookup
    device_info = {d["usb_path"]: d for d in devices}

    rules = [UDEV_HEADER]

    for usb_path, name in sorted(mapping.items()):
        info = device_info.get(usb_path, {})
        vendor = info.get("vendor", "Unknown")
        model = info.get("model", "Unknown")

        comment = f"{name}: {vendor} {model} @ USB {usb_path}"
        rule = UDEV_RULE_TEMPLATE.format(
            comment=comment,
            usb_path=usb_path,
            name=name,
        )
        rules.append(rule)

    return "".join(rules)


def save_mapping(mapping: dict[str, str], devices: list[dict], output_file: Path):
    """Save mapping to YAML file for future use."""
    if not YAML_AVAILABLE:
        return

    device_info = {d["usb_path"]: d for d in devices}

    data = {
        "ports": [
            {
                "usb_path": usb_path,
                "name": name,
                "vendor": device_info.get(usb_path, {}).get("vendor", ""),
                "model": device_info.get(usb_path, {}).get("model", ""),
            }
            for usb_path, name in sorted(mapping.items())
        ]
    }

    with open(output_file, "w") as f:
        yaml.dump(data, f, default_flow_style=False, sort_keys=False)

    print(f"Mapping saved to {output_file}")


def main():
    parser = argparse.ArgumentParser(
        description="Generate udev rules for deterministic USB serial naming"
    )
    parser.add_argument(
        "--mapping", "-m",
        type=Path,
        help="YAML file with USB path to name mapping",
    )
    parser.add_argument(
        "--output", "-o",
        type=Path,
        help="Output file for udev rules (default: stdout)",
    )
    parser.add_argument(
        "--save-mapping",
        type=Path,
        help="Save the mapping to a YAML file",
    )
    parser.add_argument(
        "--dry-run", "-n",
        action="store_true",
        help="Show what would be generated without writing files",
    )

    args = parser.parse_args()

    # Discover devices
    devices = discover_devices()

    if not devices:
        print("No USB serial devices found.", file=sys.stderr)
        sys.exit(0)

    # Get mapping
    if args.mapping:
        if not args.mapping.exists():
            print(f"Error: Mapping file not found: {args.mapping}", file=sys.stderr)
            sys.exit(1)
        mapping = load_mapping(args.mapping)
    else:
        mapping = interactive_mapping(devices)

    # Generate rules
    rules = generate_rules(mapping, devices)

    if args.dry_run:
        print("\n--- Generated udev rules ---")
        print(rules)
        print("--- End ---\n")
        return

    # Output rules
    if args.output:
        with open(args.output, "w") as f:
            f.write(rules)
        print(f"Rules written to {args.output}")
    else:
        print(rules)

    # Save mapping if requested
    if args.save_mapping:
        save_mapping(mapping, devices, args.save_mapping)


if __name__ == "__main__":
    main()
